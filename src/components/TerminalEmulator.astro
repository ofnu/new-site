---
// CTF Terminal - Forensic Investigation Challenge
---

<div class="terminal">
  <div class="terminal-output"></div>
  <div class="terminal-input-line">
    <span class="prompt">ctf-user@jail:~$</span>
    <input type="text" class="terminal-input" spellcheck="false" autocomplete="off" />
  </div>
</div>

<style>
  /* Core terminal styling */
  .terminal {
    width: 100%;
    height: 100%;
    background: #121314;
    color: #fff;
    font-family: monospace;
    overflow-y: scroll;
    scrollbar-width: none;
    -ms-overflow-style: none;
  }

  .terminal::-webkit-scrollbar {
    display: none;
  }

  .terminal-output {
    white-space: pre-wrap;
    line-height: 1.2;
  }

  .terminal-input-line {
    display: flex;
    line-height: 1.2;
  }

  .prompt {
    color: #00ff00;
  }

  .terminal-input {
    background: transparent;
    border: none;
    color: #fff;
    font-family: monospace;
    font-size: inherit;
    flex: 1;
    outline: none;
  }

  /* Output styling */
  .error { color: #ff0000; }
  .success { color: #00ff00; }
  .info { color: #0088ff; }
  .warning { color: #ffff00; }
</style>

<script>
// Multi-layered obfuscated payload with Japanese character mapping
const OBFUSCATED_PAYLOAD = `$が='g';$ん='a';$ば='n';$っ='b';$て='e';
$がんばって = ($が+$ん+$ば+$っ+$ん+$て+$て);

function Get-RandomChar { param($c) return [char]([int]$c + 3) }
function Get-UnRandomChar { param($c) return [char]([int]$c - 3) }

$あい = "aHR0cHM6Ly9zaW1wbGV4LmNoYXQvY29udGFjdCMvPz92PTItNCZzbXA9c21wJTNBJTJGJTJGWktlNHV4RjRaX2FMSkpPRXNDLVk2aFNrWGdRUzUtb2M0NDJKUUdreVA4TSUzRCU0MHNtcDE3LnNpbXBsZXguaW0lMkZmTmE1b2xENzY5dWJXNnBoalg0RGxFQjY5TWFZbUxjVCUyMyUyRiUzRnYlM0QxLTIlMjZkaCUzRE1Db3dCUVlESzJWdUF5RUFiejV1Nnly"
$うえ = "Q1ZnSHJpU2xKSlFHWkRXNjJNSDZReHQ4NXpZenBfTWhWanpRJTI1M0QlMjZzcnYlM0RvZ3R3Znl4aTNoMmg1d2VmdGpqcGpteGNsaGI1dWd1ZmE1cmN5cm1nN2o0eGxjaDdxc3I1bnVxZC5vbmlvbg=="

$おか = -join ($あい.ToCharArray() | ForEach-Object { Get-RandomChar $_ })
$きく = -join ($うえ.ToCharArray() | ForEach-Object { Get-RandomChar $_ })

$けこ = Get-WmiObject Win32_OperatingSystem
if ($けこ.OSArchitecture -eq "64-bit") {
    $さし = [System.Text.Encoding]::UTF8.GetString([Convert]::FromBase64String(
        -join ($おか.ToCharArray() | ForEach-Object { Get-UnRandomChar $_ })
    ))
    $すせ = [System.Text.Encoding]::UTF8.GetString([Convert]::FromBase64String(
        -join ($きく.ToCharArray() | ForEach-Object { Get-UnRandomChar $_ })
    ))
}

$そた = Measure-Command { Start-Sleep -Milliseconds 1 }
if ($そた.TotalMilliseconds -lt 100) {
    # Layer 5: Memory allocation to avoid direct string storage
    $ちつ = [System.Runtime.InteropServices.Marshal]::AllocHGlobal(1024)
    $てと = [System.Runtime.InteropServices.Marshal]::AllocHGlobal(1024)
    
    [System.Runtime.InteropServices.Marshal]::Copy([System.Text.Encoding]::UTF8.GetBytes($さし), 0, $ちつ, $さし.Length)
    [System.Runtime.InteropServices.Marshal]::Copy([System.Text.Encoding]::UTF8.GetBytes($すせ), 0, $てと, $すせ.Length)
    
    try {
        $なに = [System.Text.Encoding]::UTF8.GetString([System.Runtime.InteropServices.Marshal]::PtrToStructure($ちつ, [Type][byte[]]))
        $ぬね = [System.Text.Encoding]::UTF8.GetString([System.Runtime.InteropServices.Marshal]::PtrToStructure($てと, [Type][byte[]]))
        
        $のは = $なに + $ぬね
        Write-Host "がんばって! Try harder ;)"
        
        [System.Runtime.InteropServices.Marshal]::FreeHGlobal($ちつ)
        [System.Runtime.InteropServices.Marshal]::FreeHGlobal($てと)
        
        return $のは
    } catch {
        Write-Error "申し訳ありません。エラーが発生しました。"
    }
}`;

// Filesystem types
interface FSNode {
  type: 'dir' | 'file' | 'executable';
  content?: Record<string, FSNode> | string;
  permissions?: string;
  timestamp?: string;
}

// Filesystem implementation
class FileSystem {
  root: Record<string, FSNode>;
  currentPath: string[];

  constructor() {
    this.root = {
      home: {
        type: 'dir',
        content: {
          'ctf-user': {
            type: 'dir',
            content: {
              'Documents': {
                type: 'dir',
                content: {
                  'IR-Case-2024-001': {
                    type: 'dir',
                    content: {
                      'suspect.ps1': {
                        type: 'file',
                        content: OBFUSCATED_PAYLOAD,
                        permissions: 'rw-r--r--',
                        timestamp: '2024-02-15 03:47:22'
                      },
                      'analysis_notes.txt': {
                        type: 'file',
                        content: `INCIDENT REPORT - CASE #2024-001
MALWARE ANALYSIS FINDINGS:

Initial Triage:
- PowerShell script discovered on compromised Windows host
- Heavy obfuscation detected
- Possible C2 indicators
- Japanese character usage observed

Static Analysis:
1. Multiple obfuscation layers detected
2. Environmental checks present
3. Anti-debugging techniques observed
4. Memory manipulation routines identified
5. Base64 encoded payloads
6. Suspicious character substitution patterns

File Information:
MD5:    8a7b8345f62364de1c92a7feb32c936d
SHA256: e459a3bb74c14faee6429102a8b73d951e2f98cdaf27a13afb465f17e702437b
First Seen: 2024-02-15 03:47:22 UTC
File Size: 3.7 KB

WARNING: DO NOT EXECUTE ON LIVE SYSTEM
CONTAINMENT STATUS: ISOLATED
PRIORITY: HIGH

TODO: Need to figure out what この悪意のあるスクリプト is trying to hide...`,
                        permissions: 'rw-r--r--',
                        timestamp: '2024-02-15 04:22:15'
                      },
                      'strings.txt': {
                        type: 'file',
                        content: `Found interesting strings in suspect.ps1:

[Unicode Strings]
がんばって
申し訳ありません
この悪意のあるスクリプト

[ASCII Strings]
base64
marshal
AllocHGlobal
Win32_OperatingSystem
UTF8.GetString
Measure-Command
PtrToStructure

[Entropy Analysis]
Base64 encoded sections detected
High entropy regions indicate encryption/encoding
Multiple character set usage (ASCII + Unicode)

[Potential C2 Indicators]
Redacted pending further analysis...

Note: Character analysis suggests possible connection to APT[REDACTED]
Last Updated: 2024-02-15 04:25:33 UTC`,
                        permissions: 'rw-r--r--',
                        timestamp: '2024-02-15 04:25:33'
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    };
    
    this.currentPath = ['home', 'ctf-user'];
  }

  getCurrentDirectory(): string {
    return '/' + this.currentPath.join('/');
  }

  resolvePath(path: string): string[] {
    if (path.startsWith('/')) {
      return path.split('/').filter(Boolean);
    }
    if (path === '.') {
      return [...this.currentPath];
    }
    return [...this.currentPath, ...path.split('/').filter(Boolean)];
  }

  getNode(path: string): FSNode | null {
    let current: FSNode | Record<string, FSNode> = { type: 'dir', content: this.root };
    const pathParts = this.resolvePath(path);
    const resolvedPath: string[] = [];
    
    for (const part of pathParts) {
      if (part === '..') {
        resolvedPath.pop();
        continue;
      }
      resolvedPath.push(part);
    }

    for (const part of resolvedPath) {
      if (!('content' in current) || typeof current.content === 'string' || !current.content[part]) {
        return null;
      }
      current = current.content[part];
    }
    return current as FSNode;
  }
}

// Terminal implementation
class Terminal {
  element: HTMLElement;
  output: HTMLElement;
  input: HTMLInputElement;
  fileSystem: FileSystem;
  history: string[];
  historyIndex: number;
  currentTabCompletions: string[] = [];
  tabIndex: number = 0;

  constructor(element: HTMLElement) {
    this.element = element;
    this.output = element.querySelector('.terminal-output') as HTMLElement;
    this.input = element.querySelector('.terminal-input') as HTMLInputElement;
    this.fileSystem = new FileSystem();
    this.history = [];
    this.historyIndex = -1;

    this.setupEventListeners();
    this.printWelcome();
  }

  setupEventListeners() {
    this.input.addEventListener('keydown', (e: KeyboardEvent) => {
      if (e.key === 'Tab') {
        e.preventDefault();
        this.handleTabCompletion();
      } else if (e.key === 'Enter') {
        const command = this.input.value.trim();
        this.executeCommand(command);
        this.input.value = '';
        
        if (command) {
          this.history.push(command);
          this.historyIndex = this.history.length;
        }
      } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        if (this.historyIndex > 0) {
          this.historyIndex--;
          this.input.value = this.history[this.historyIndex];
        }
      } else if (e.key === 'ArrowDown') {
        e.preventDefault();
        if (this.historyIndex < this.history.length - 1) {
          this.historyIndex++;
          this.input.value = this.history[this.historyIndex];
        } else {
          this.historyIndex = this.history.length;
          this.input.value = '';
        }
      } else {
        this.currentTabCompletions = [];
        this.tabIndex = 0;
      }
    });

    this.element.addEventListener('click', () => {
      this.input.focus();
    });
  }

  handleTabCompletion() {
    const input = this.input.value;
    const [cmd, ...args] = input.trim().split(' ');
    
    if (this.currentTabCompletions.length === 0) {
      const currentDir = this.fileSystem.getNode('.');
      if (!currentDir || typeof currentDir.content === 'string') return;

      const partial = args[args.length - 1] || '';
      const items = Object.keys(currentDir.content);
      
      this.currentTabCompletions = items.filter(item => 
        item.startsWith(partial)
      );
    }

    if (this.currentTabCompletions.length > 0) {
      const completion = this.currentTabCompletions[this.tabIndex];
      const parts = input.split(' ');
      parts.pop();
      if (parts.length === 0) {
        this.input.value = completion;
      } else {
        this.input.value = `${parts.join(' ')} ${completion}`;
      }
      
      this.tabIndex = (this.tabIndex + 1) % this.currentTabCompletions.length;
    }
  }

  println(text: string, className: string = '') {
    const line = document.createElement('div');
    line.textContent = text;
    if (className) line.className = className;
    this.output.appendChild(line);
    requestAnimationFrame(() => {
      this.output.scrollTop = this.output.scrollHeight;
    });
  }

  printCommand(command: string) {
    this.println(`${this.getPrompt()} ${command}`);
  }

  getPrompt(): string {
    return `ctf-user@jail:${this.fileSystem.getCurrentDirectory()}$`;
  }

  printWelcome() {
    this.println('=== Welcome to CTF Jail v1.0 ===', 'success');
    this.println('Try to escape... if you can.', 'info');
    this.println('Type "help" for available commands.\n');
  }

  executeCommand(command: string) {
    if (!command) return;
    
    this.printCommand(command);
    
    const [cmd, ...args] = command.split(' ');
    
    switch (cmd) {
      case 'help':
        this.println('Available commands:');
        this.println('  ls [-la] [path]    - List directory contents');
        this.println('  cd [path]          - Change directory');
        this.println('  cat [file]         - Display file contents');
        this.println('  pwd                - Print working directory');
        this.println('  help               - Show this help message');
        break;

      case 'ls':
        const path = args[0] || '.';
        const node = this.fileSystem.getNode(path);
        if (!node || node.type !== 'dir' || typeof node.content === 'string') {
          this.println(`ls: cannot access '${path}': No such file or directory`, 'error');
          break;
        }
        
        if (args.includes('-la') || args.includes('-al')) {
          Object.entries(node.content).forEach(([name, file]) => {
            const prefix = file.type === 'dir' ? 'd' : '-';
            const perms = file.permissions || 'rwxr-xr-x';
            this.println(`${prefix}${perms} ctf-user ctf-user ${name}${file.type === 'dir' ? '/' : ''}`);
          });
        } else {
          Object.entries(node.content).forEach(([name, file]) => {
            this.println(file.type === 'dir' ? `${name}/` : name);
          });
        }
        break;

      case 'cd':
        if (args[0] === '..') {
          if (this.fileSystem.currentPath.length > 1) {
            this.fileSystem.currentPath.pop();
          }
          break;
        }
        const newPath = args[0] || '/home/ctf-user';
        const targetNode = this.fileSystem.getNode(newPath);
        if (!targetNode || targetNode.type !== 'dir') {
          this.println(`cd: no such directory: ${newPath}`, 'error');
          break;
        }
        this.fileSystem.currentPath = this.fileSystem.resolvePath(newPath);
        break;

      case 'cat':
        if (!args.length) {
          this.println('cat: missing operand', 'error');
          break;
        }
        const file = this.fileSystem.getNode(args[0]);
        if (!file || file.type !== 'file' || typeof file.content !== 'string') {
          this.println(`cat: ${args[0]}: No such file`, 'error');
          break;
        }
        this.println(file.content);
        break;

      case 'pwd':
        this.println(this.fileSystem.getCurrentDirectory());
        break;

      default:
        this.println(`${cmd}: command not found`, 'error');
    }
  }
}

// Initialize terminal
document.addEventListener('DOMContentLoaded', () => {
  const terminalElement = document.querySelector('.terminal');
  if (terminalElement instanceof HTMLElement) {
    new Terminal(terminalElement);
  }
});

// Error handling
window.addEventListener('error', (event) => {
  console.error('Terminal error:', event.error);
});
</script>